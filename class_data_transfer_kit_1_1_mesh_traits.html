<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Data Transfer Kit: DataTransferKit::MeshTraits&lt; MeshType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Data Transfer Kit
   &#160;<span id="projectnumber">Development Version</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_data_transfer_kit.html">DataTransferKit</a></li><li class="navelem"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html">MeshTraits</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">DataTransferKit::MeshTraits&lt; MeshType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Mesh traits definitions.  
 <a href="class_data_transfer_kit_1_1_mesh_traits.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_d_t_k___mesh_traits_8hpp_source.html">DTK_MeshTraits.hpp</a>&gt;</code></p>

<p><a href="class_data_transfer_kit_1_1_mesh_traits-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad432d5eb8833d17a6b9ab8ed7bde877a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad432d5eb8833d17a6b9ab8ed7bde877a"></a>
typedef MeshType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#ad432d5eb8833d17a6b9ab8ed7bde877a">mesh_type</a></td></tr>
<tr class="memdesc:ad432d5eb8833d17a6b9ab8ed7bde877a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for mesh type. <br/></td></tr>
<tr class="memitem:ac368b56f73eebbd94e5d1e153933d41c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac368b56f73eebbd94e5d1e153933d41c"></a>
typedef <br class="typebreak"/>
MeshType::global_ordinal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#ac368b56f73eebbd94e5d1e153933d41c">global_ordinal_type</a></td></tr>
<tr class="memdesc:ac368b56f73eebbd94e5d1e153933d41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for global ordinal type. This type must implement. <br/></td></tr>
<tr class="memitem:aac9df5d1c7211649d82398baa8e304db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac9df5d1c7211649d82398baa8e304db"></a>
typedef std::iterator<br class="typebreak"/>
&lt; std::random_access_iterator_tag, <br class="typebreak"/>
const <a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#ac368b56f73eebbd94e5d1e153933d41c">global_ordinal_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#aac9df5d1c7211649d82398baa8e304db">const_vertex_iterator</a></td></tr>
<tr class="memdesc:aac9df5d1c7211649d82398baa8e304db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for random access const iterator to vertex global ordinal. <br/></td></tr>
<tr class="memitem:a44e828d7c26b397dd1a220e849a4eab9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44e828d7c26b397dd1a220e849a4eab9"></a>
typedef std::iterator<br class="typebreak"/>
&lt; std::random_access_iterator_tag, <br class="typebreak"/>
const double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#a44e828d7c26b397dd1a220e849a4eab9">const_coordinate_iterator</a></td></tr>
<tr class="memdesc:a44e828d7c26b397dd1a220e849a4eab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for random access const iterator to coordinate. <br/></td></tr>
<tr class="memitem:a3f385536de7124ee950a1e36826c4cbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f385536de7124ee950a1e36826c4cbb"></a>
typedef std::iterator<br class="typebreak"/>
&lt; std::random_access_iterator_tag, <br class="typebreak"/>
const <a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#ac368b56f73eebbd94e5d1e153933d41c">global_ordinal_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#a3f385536de7124ee950a1e36826c4cbb">const_element_iterator</a></td></tr>
<tr class="memdesc:a3f385536de7124ee950a1e36826c4cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for random access const iterator to element global ordinal. <br/></td></tr>
<tr class="memitem:add835be877702a4e1b7c3823ba01924b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add835be877702a4e1b7c3823ba01924b"></a>
typedef std::iterator<br class="typebreak"/>
&lt; std::random_access_iterator_tag, <br class="typebreak"/>
const <a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#ac368b56f73eebbd94e5d1e153933d41c">global_ordinal_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#add835be877702a4e1b7c3823ba01924b">const_connectivity_iterator</a></td></tr>
<tr class="memdesc:add835be877702a4e1b7c3823ba01924b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for random access const iterator to connectivity values. <br/></td></tr>
<tr class="memitem:aaaaf5aa2210cfdeac9ba0aa3751ad19f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaaaf5aa2210cfdeac9ba0aa3751ad19f"></a>
typedef std::iterator<br class="typebreak"/>
&lt; std::random_access_iterator_tag, <br class="typebreak"/>
const int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#aaaaf5aa2210cfdeac9ba0aa3751ad19f">const_permutation_iterator</a></td></tr>
<tr class="memdesc:aaaaf5aa2210cfdeac9ba0aa3751ad19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for random access const iterator to connectivity permutation. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aec451584e1a44ec97561f99bfeb4c085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec451584e1a44ec97561f99bfeb4c085"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#aec451584e1a44ec97561f99bfeb4c085">vertexDim</a> (const MeshType &amp;mesh_block)</td></tr>
<tr class="memdesc:aec451584e1a44ec97561f99bfeb4c085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension of the vertices in this mesh block. <br/></td></tr>
<tr class="memitem:a889efc8bf9b35d7ec67459cbc8da9598"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a889efc8bf9b35d7ec67459cbc8da9598"></a>
static <a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#aac9df5d1c7211649d82398baa8e304db">const_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#a889efc8bf9b35d7ec67459cbc8da9598">verticesBegin</a> (const MeshType &amp;mesh_block)</td></tr>
<tr class="memdesc:a889efc8bf9b35d7ec67459cbc8da9598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the const iterator to the beginning of the vertex global ordinal block in this mesh block. <br/></td></tr>
<tr class="memitem:adf5302a807b7a5caa57a055066f6c3ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf5302a807b7a5caa57a055066f6c3ef"></a>
static <a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#aac9df5d1c7211649d82398baa8e304db">const_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#adf5302a807b7a5caa57a055066f6c3ef">verticesEnd</a> (const MeshType &amp;mesh_block)</td></tr>
<tr class="memdesc:adf5302a807b7a5caa57a055066f6c3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the const iterator to the end of the vertex global ordinal block in this mesh block. <br/></td></tr>
<tr class="memitem:a7ac1e01a2faf848c2e4526a31ee5161f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ac1e01a2faf848c2e4526a31ee5161f"></a>
static <a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#a44e828d7c26b397dd1a220e849a4eab9">const_coordinate_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#a7ac1e01a2faf848c2e4526a31ee5161f">coordsBegin</a> (const MeshType &amp;mesh_block)</td></tr>
<tr class="memdesc:a7ac1e01a2faf848c2e4526a31ee5161f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the const iterator to the beginning of the vertex coordinate block in this mesh block. These coordinates are required to be three dimensional and blocked. ( x0, x1, x2, ... , xN, y0, y1, y2, ... , yN, z0, z1, z2, ... , zN ) <br/></td></tr>
<tr class="memitem:a3e5cca794d4ce5e56460a27cb9b6e70c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e5cca794d4ce5e56460a27cb9b6e70c"></a>
static <a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#a44e828d7c26b397dd1a220e849a4eab9">const_coordinate_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#a3e5cca794d4ce5e56460a27cb9b6e70c">coordsEnd</a> (const MeshType &amp;mesh_block)</td></tr>
<tr class="memdesc:a3e5cca794d4ce5e56460a27cb9b6e70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the const iterator to the end of the vertex coordinate block in this mesh block. These coordinates are requried to be three dimensional and blocked. ( x0, x1, x2, ... , xN, y0, y1, y2, ... , yN, z0, z1, z2, ... , zN ) <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a95b08f1ffbb8dbd63b0d596df4c55fef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95b08f1ffbb8dbd63b0d596df4c55fef"></a>
static <a class="el" href="namespace_data_transfer_kit.html#a673ffda6737b51597f90991c5ba8d3a5">DTK_ElementTopology</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#a95b08f1ffbb8dbd63b0d596df4c55fef">elementTopology</a> (const MeshType &amp;mesh_block)</td></tr>
<tr class="memdesc:a95b08f1ffbb8dbd63b0d596df4c55fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element topology for this mesh block (DTK_ElementTopology enum). <br/></td></tr>
<tr class="memitem:a919f2e6db43a2f95ea785a1b7d068550"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a919f2e6db43a2f95ea785a1b7d068550"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#a919f2e6db43a2f95ea785a1b7d068550">verticesPerElement</a> (const MeshType &amp;mesh_block)</td></tr>
<tr class="memdesc:a919f2e6db43a2f95ea785a1b7d068550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of vertices that constructs an individual element in this mesh block. All elements in the mesh must be constructed with the same number of vertices. <br/></td></tr>
<tr class="memitem:a5c3b6652e5b6ab698adc8b42d6b4c15a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c3b6652e5b6ab698adc8b42d6b4c15a"></a>
static <a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#a3f385536de7124ee950a1e36826c4cbb">const_element_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#a5c3b6652e5b6ab698adc8b42d6b4c15a">elementsBegin</a> (const MeshType &amp;mesh_block)</td></tr>
<tr class="memdesc:a5c3b6652e5b6ab698adc8b42d6b4c15a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the const iterator to the beginning of the element global ordinal block in this mesh block. <br/></td></tr>
<tr class="memitem:ac620f0e077b4c19cb8fb89d3b30fc474"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac620f0e077b4c19cb8fb89d3b30fc474"></a>
static <a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#a3f385536de7124ee950a1e36826c4cbb">const_element_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#ac620f0e077b4c19cb8fb89d3b30fc474">elementsEnd</a> (const MeshType &amp;mesh_block)</td></tr>
<tr class="memdesc:ac620f0e077b4c19cb8fb89d3b30fc474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the const iterator to the end of the element global ordinal block in this mesh block. <br/></td></tr>
<tr class="memitem:a46d1da9aff157e4486da389454236126"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46d1da9aff157e4486da389454236126"></a>
static <a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#add835be877702a4e1b7c3823ba01924b">const_connectivity_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#a46d1da9aff157e4486da389454236126">connectivityBegin</a> (const MeshType &amp;mesh_block)</td></tr>
<tr class="memdesc:a46d1da9aff157e4486da389454236126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the const iterator to the beginning of the element connectivity block in this mesh block. The connectivity entries are required to be blocked. ( element0( c0 ), element1( c0 ), ... , elementN( c0 ), element0( c1 ), element1( c1 ), ... , elementN( c1 ), ... , elementN( cn ) ) <br/></td></tr>
<tr class="memitem:af7104119cf92937433f5ca5dc2b51a98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7104119cf92937433f5ca5dc2b51a98"></a>
static <a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#add835be877702a4e1b7c3823ba01924b">const_connectivity_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#af7104119cf92937433f5ca5dc2b51a98">connectivityEnd</a> (const MeshType &amp;mesh_block)</td></tr>
<tr class="memdesc:af7104119cf92937433f5ca5dc2b51a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the const iterator to the end of the element connectivity block in this mesh block. The connectivity entries are required to be blocked. ( element0( c0 ), element1( c0 ), ... , elementN( c0 ), element0( c1 ), element1( c1 ), ... , elementN( c1 ), ... , elementN( cn ) ) <br/></td></tr>
<tr class="memitem:ab57a8cf9c179600088d67e3be4ebd066"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab57a8cf9c179600088d67e3be4ebd066"></a>
static <a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#aaaaf5aa2210cfdeac9ba0aa3751ad19f">const_permutation_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#ab57a8cf9c179600088d67e3be4ebd066">permutationBegin</a> (const MeshType &amp;mesh_block)</td></tr>
<tr class="memdesc:ab57a8cf9c179600088d67e3be4ebd066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the const iterator to the beginning of the element connectivity permutation list. <br/></td></tr>
<tr class="memitem:a368d88ae1802078837ad9e189c51327f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a368d88ae1802078837ad9e189c51327f"></a>
static <a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#aaaaf5aa2210cfdeac9ba0aa3751ad19f">const_permutation_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html#a368d88ae1802078837ad9e189c51327f">permutationEnd</a> (const MeshType &amp;mesh_block)</td></tr>
<tr class="memdesc:a368d88ae1802078837ad9e189c51327f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the const iterator to the end of the element connectivity permutation list. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename MeshType&gt;<br/>
class DataTransferKit::MeshTraits&lt; MeshType &gt;</h3>

<p>Mesh traits definitions. </p>
<p>In order to access DTK mesh services, a subset of the information needed to describe the mesh is required. This subset consists of vertices and their coordinates, elements and the vertices that construct them, and the communicator over which they are defined. The vertices that construct an element have both a canonical ordering consistent across all elements of that topology in a mesh and a permutation list that describes how this ordering varies from DTK canonical ordering.</p>
<p>Vertices are the lowest level geometric component of the mesh. All vertices have a globally unique ordinal serving as an identification number for the vertex in global operations. A vertex can have 1, 2, or 3 dimensions but all vertices in a mesh must have the same dimension. To specify its geometric position, each vertex has Cartesian (x,y,z) coordinates. A vertex must provide only the coordinates for the specified vertex dimension, no more or no less (e.g. a 2 dimensional vertex must provide x and y coordinates but not a z coordinate). A vertex may be repeated any number of times across the parallel domain with unlimited local and global instances. However, every vertex with the same globally unique ordinal must have the same coordinates. We make a distinction here between vertices and nodes. In the context of DTK, a vertex is purely a geometric object. It describes the spatial positioning and geometric bounds of an element. A node is purely a mathematical object. It descrbibes the descretization associated with a particular element described within the natural coordinate system of that element. It is possible that in the physical coordinate frame that a node and vertex may occupy the same geometric location, however DTK does not consider nodes in its formulation.</p>
<p>Elements are the second level of abstraction in the mesh description above vertices. All elements have a globally unique ordinal serving as an identification number for the element in global operations. This globally unique ordinal can be the same as a globally unique ordinal for a vertex in the mesh as DTK distinguishes between vertices and elements. An element has a topology defining its physical structure (e.g. tetrahedron, hexahedron, etc.) and a number of vertices needed to generate that topology. Elements are constructed from vertices via a connectivity list. The connectivity list for a particular element will contain the unique vertex global ordinals that construct its linear form. An element may be repeated any number of times across the parallel domain (i.e. it may have unlimited local instances), however, every globally unique ordinal must have the same connectivity list associated with it. For consistency, DTK uses the MoaB Canonical Numbering (MBCN) scheme as a canonical ordering scheme. Each element in a client mesh can be described with a connectivity list using any canonical scheme of choice, however, the relationship between this canonical numbering scheme and the DTK canonical numbering scheme must be made available. Each element topology is therefore also described by a permutation list. A permutation list specifies the variation in ordering between the DTK canonical numbering scheme and the client canonical numbering scheme. A permutation list must be described globally, regardless of whether or not elements exist on a particular process. See DTK_ElementTopology for canonical element topologies as defined by DTK. Mesh elements may not intersect any other elements in a single mesh description. An element may intersect other elements if those elements exist in another mesh (this is in fact a common situation in data transfer).</p>
<p><a class="el" href="class_data_transfer_kit_1_1_mesh_traits.html" title="Mesh traits definitions.">MeshTraits</a> correlate to the basic concept of a single topology mesh block within DTK. They have the following properties:</p>
<p>Mesh vertices have D dimensions and may not exceed three dimensions <img class="formulaInl" alt="$ \Big\{ d_0, ..., d_D \Big\} $" src="form_31.png"/>. Vertices are identified by a unique global ordinal. If there are N vertices in the mesh then their ordinals are given as <img class="formulaInl" alt="$ \Big\{ n_0, n_1, n_2, ..., n_N \Big\} $" src="form_32.png"/>. Vertex coordinates are blocked by dimension such that if there are N vertices in the mesh block then they are stored as <img class="formulaInl" alt="$ \Big\{ x^0_0, x^1_0, x^2_0, ..., x^N_0, ..., x^0_D, x^1_D, x^2_D, ... x^N_D \Big\} $" src="form_33.png"/>. The ordering of the vertices is implicilty bound to the global ordinals such that the coordinates for a vertex with ordinal <img class="formulaInl" alt="$ n_N $" src="form_29.png"/> are <img class="formulaInl" alt="$ \Big\{ x^N_0, x^N_1, x^N_2 \Big\} $" src="form_34.png"/>.</p>
<p>Mesh elements have a topology defined by a DTK_ElementTopology enumeration with a specified number of vertices, P, needed to construct the topology. Elements are identified by a unique global ordinal. If there are M elements in the mesh then their ordinals are given as <img class="formulaInl" alt="$ \Big\{ m_0, m_1, m_2, ..., m_M \Big\} $" src="form_35.png"/>. The connecting vertices for the elements in the mesh are defined using the vertex global ordinals such that an element, m, can be described with a list <img class="formulaInl" alt="$ \Big\{ n^0_m, n^1_m, ..., n^P_m \Big\} $" src="form_37.png"/>. The connectivity information is accessed by blocks in the same manner as coordinates such that <img class="formulaInl" alt="$ \Big\{ n^0_0, n^0_1, n^0_2, ..., n^0_M, n^1_0, n^1_1, n^1_2, ..., n^1_M, ..., n^P_0, n^P_1, ..., n^P_M \Big\} $" src="form_38.png"/>. Finally, a permutation list defines the difference in ordering between a client element topology connectivity ordering and DTK canonical ordering. This list, defined as <img class="formulaInl" alt="$ \Big\{ p^0, p^1, ..., p^P \Big\}$" src="form_39.png"/>, must be defined for every instance of the mesh, regardless of whether or not the mesh contains any data. Here, the entry <img class="formulaInl" alt="$ p^P $" src="form_40.png"/> gives which canonical vertex index in the client connectivity list cooresponds to the <img class="formulaInl" alt="$ P^{th} $" src="form_41.png"/> vertex in the DTK canonical vertex list for that topology. </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_d_t_k___mesh_traits_8hpp_source.html">DTK_MeshTraits.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Aug 7 2012 18:09:49 for Data Transfer Kit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
